import { exec } from "child_process"
import { existsSync, promises as fs, readFileSync, writeFileSync } from "fs"
import path from "path"
import { rimraf } from "rimraf"
import { registrySchema } from "shadcn/schema"

import { getAllBlocks } from "../lib/blocks"
import { STYLES, type Style } from "../registry/styles"

/**
 * å°† themes.css å†…è”åˆ° globals.cssï¼Œè§£å†³ç”¨æˆ·å®‰è£…å @import "./themes.css" è·¯å¾„å¤±æ•ˆçš„é—®é¢˜ã€‚
 * æ„å»ºæ—¶ä¸´æ—¶æ›¿æ¢ globals.cssï¼Œæ„å»ºå®Œæˆåæ¢å¤ã€‚
 */
async function bakeStyleGlobals(styleName: string): Promise<() => void> {
  const styleDir = path.join(process.cwd(), "registry", styleName, "style")
  const globalsPath = path.join(styleDir, "globals.css")
  const themesPath = path.join(styleDir, "themes.css")

  if (!existsSync(globalsPath) || !existsSync(themesPath)) {
    return () => {}
  }

  const globalsRaw = readFileSync(globalsPath, "utf-8")
  const themesContent = readFileSync(themesPath, "utf-8")

  const importRegex = /@import\s+["']\.\/themes\.css["']\s*;?\s*\n?/
  if (!importRegex.test(globalsRaw)) {
    return () => {}
  }

  const bakedContent = globalsRaw.replace(importRegex, () => {
    return `/* themes.css - inlined for registry distribution */\n${themesContent}\n\n`
  })

  const backupPath = path.join(styleDir, "globals.css.bak")
  writeFileSync(backupPath, globalsRaw, "utf-8")
  writeFileSync(globalsPath, bakedContent, "utf-8")

  console.log(`   ğŸ“¦ Baked themes.css into globals.css for ${styleName}`)

  return () => {
    writeFileSync(globalsPath, globalsRaw, "utf-8")
    if (existsSync(backupPath)) {
      fs.unlink(backupPath).catch(() => {})
    }
  }
}

async function buildRegistryIndex(styles: Style[]) {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, Record<string, any>> = {`

  for (const style of styles) {
    // Dynamically import the registry for this style.
    const { registry: importedRegistry } = await import(
      `../registry/${style.name}/registry.ts`
    )

    // Validate the registry schema.
    const parseResult = registrySchema.safeParse(importedRegistry)
    if (!parseResult.success) {
      console.error(`âŒ Registry validation failed for ${style.name}:`)
      console.error(parseResult.error.format())
      throw new Error(`Invalid registry schema for ${style.name}`)
    }

    const registry = parseResult.data

    index += `
  "${style.name}": {`

    for (const item of registry.items) {
      const files =
        item.files?.map((file) => ({
          path: typeof file === "string" ? file : file.path,
          type: typeof file === "string" ? item.type : file.type,
          target: typeof file === "string" ? undefined : file.target,
        })) ?? []

      if (files.length === 0) {
        continue
      }

      const componentPath =
        item.type !== "registry:style" && item.files?.[0]?.path
          ? `@/registry/${style.name}/${item.files[0].path}`
          : ""

      index += `
    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${files.map((file) => {
        const filePath = `registry/${style.name}/${file.path}`
        return `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}"
      }`
      })}],
      component: ${
        componentPath
          ? `React.lazy(async () => {
        const mod = await import("${componentPath}")
        const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || item.name
        return { default: mod.default || mod[exportName] }
      })`
          : "null"
      },
      categories: ${JSON.stringify(item.categories)},
      meta: ${JSON.stringify(item.meta)},
    },`
    }

    index += `
  },`
  }

  index += `
}`

  console.log(
    `#ï¸âƒ£  Built multi-style index with ${styles.length} styles: ${styles.map((s) => s.name).join(", ")}`
  )

  // Write unified index.
  rimraf.sync(path.join(process.cwd(), "registry/__index__.tsx"))
  await fs.writeFile(path.join(process.cwd(), "registry/__index__.tsx"), index)
}

async function buildRegistryJsonFile(styleName: string) {
  // 1. Import the registry for this style.
  const { registry: importedRegistry } = await import(
    `../registry/${styleName}/registry.ts`
  )

  // 2. Validate the registry schema.
  const parseResult = registrySchema.safeParse(importedRegistry)
  if (!parseResult.success) {
    console.error(`âŒ Registry validation failed for ${styleName}:`)
    console.error(parseResult.error.format())
    throw new Error(`Invalid registry schema for ${styleName}`)
  }

  const registry = parseResult.data

  // 3. Fix the path for registry items and convert block dependencies to full URLs.
  // Get the base URL for the registry (can be configured via environment variable)
  const registryBaseUrl = process.env.REGISTRY_BASE_URL || "http://localhost:3000"
  const registryPath = styleName === "new-york-v4" ? `/r/styles/${styleName}` : `/r/${styleName}`
  
  const fixedRegistry = {
    ...registry,
    items: registry.items.map((item) => {
      const files = item.files?.map((file) => {
        return {
          ...file,
          path: `registry/${styleName}/${file.path}`,
        }
      })

      // Convert registry dependencies to full URLs for remote installs.
      const fixedDependencies = item.registryDependencies?.map((dep) => {
        // If already a full URL, keep it as is.
        if (typeof dep === "string" && dep.startsWith("http")) {
          return dep
        }

        // Convert any known registry item (style/ui/block/etc.) to full URL.
        const depItem = registry.items.find((i) => i.name === dep)
        if (depItem) {
          return `${registryBaseUrl}${registryPath}/${dep}.json`
        }

        // Keep unknown dependencies as-is.
        return dep
      })

      return {
        ...item,
        files,
        registryDependencies: fixedDependencies,
      }
    }),
  }

  // 3. Create the output directory and write registry.json.
  const outputDir = path.join(
    process.cwd(),
    styleName === "new-york-v4" ? `public/r/styles/${styleName}` : `public/r/${styleName}`
  )
  await fs.mkdir(outputDir, { recursive: true })

  // 4. Write registry.json to output directory and format it.
  const registryJsonPath = path.join(outputDir, "registry.json")
  await fs.writeFile(registryJsonPath, JSON.stringify(fixedRegistry, null, 2))
  // Note: Prettier formatting is handled by the registry:build script in package.json

  // 5. Write temporary registry file needed by shadcn build.
  const tempRegistryPath = path.join(process.cwd(), `registry-${styleName}.json`)
  await fs.writeFile(tempRegistryPath, JSON.stringify(fixedRegistry, null, 2))
}

async function buildRegistry(styleName: string) {
  return new Promise((resolve, reject) => {
    const outputPath =
      styleName === "new-york-v4" ? `public/r/styles/${styleName}` : `public/r/${styleName}`
    const cmd = `npx shadcn build registry-${styleName}.json --output ${outputPath}`
    const process = exec(cmd)

    let stdout = ""
    let stderr = ""
    
    process.stdout?.on("data", (data) => {
      const output = data.toString()
      stdout += output
      // å®æ—¶è¾“å‡ºåˆ°æ§åˆ¶å°
      console.log(output.trimEnd())
    })
    
    process.stderr?.on("data", (data) => {
      const output = data.toString()
      stderr += output
      // å®æ—¶è¾“å‡ºåˆ°æ§åˆ¶å°
      console.error(output.trimEnd())
    })

    process.on("exit", (code) => {
      if (code === 0) {
        resolve(undefined)
      } else {
        reject(new Error(`Process exited with code ${code}\nCommand: ${cmd}\nStdout: ${stdout}\nStderr: ${stderr}`))
      }
    })
  })
}

async function buildBlocksIndex() {
  const blocks = await getAllBlocks(["registry:block"])

  const payload = blocks.map((block) => ({
    name: block.name,
    description: block.description,
    categories: block.categories,
  }))

  rimraf.sync(path.join(process.cwd(), "registry/__blocks__.json"))
  await fs.writeFile(
    path.join(process.cwd(), "registry/__blocks__.json"),
    JSON.stringify(payload, null, 2)
  )
  // Note: Prettier formatting is handled by the registry:build script in package.json
}

try {
  const styles = Array.from(STYLES)
  console.log(`ğŸ¨ Found ${styles.length} styles: ${styles.map((s) => s.name).join(", ")}`)

  // Build unified multi-style index.
  console.log("\nğŸ—‚ï¸ Building unified multi-style registry/__index__.tsx...")
  await buildRegistryIndex(styles)

  const restoreFns: Array<() => void> = []
  try {
    for (const style of styles) {
      console.log(`\nğŸ“¦ Processing style: ${style.name}`)

      const restore = await bakeStyleGlobals(style.name)
      if (restore) restoreFns.push(restore)

      console.log(`ğŸ’… Building registry-${style.name}.json...`)
      await buildRegistryJsonFile(style.name)

      console.log(`ğŸ—ï¸ Building registry for ${style.name}...`)
      await buildRegistry(style.name)
    }
  } finally {
    for (const restore of restoreFns) {
      restore()
    }
    if (restoreFns.length > 0) {
      console.log("   â†©ï¸ Restored globals.css from bake")
    }
  }

  console.log("\nğŸ—‚ï¸ Building registry/__blocks__.json...")
  await buildBlocksIndex()

  // Generate root registry.json for default style (first style)
  if (styles.length > 0) {
    console.log(`\nğŸ“ Generating root registry.json from ${styles[0].name}...`)
    const defaultStyle = styles[0]
    const { registry: importedRegistry } = await import(
      `../registry/${defaultStyle.name}/registry.ts`
    )
    const parseResult = registrySchema.safeParse(importedRegistry)
    if (parseResult.success) {
      const registry = parseResult.data
      const fixedRegistry = {
        ...registry,
        items: registry.items.map((item) => {
          const files = item.files?.map((file) => {
            return {
              ...file,
              path: `registry/${defaultStyle.name}/${file.path}`,
            }
          })
          return {
            ...item,
            files,
          }
        }),
      }
      const rootRegistryPath = path.join(process.cwd(), "registry.json")
      await fs.writeFile(rootRegistryPath, JSON.stringify(fixedRegistry, null, 2))
      console.log(`âœ… Root registry.json generated`)
    }
  }

  // Clean up intermediate files.
  console.log("\nğŸ§¹ Cleaning up intermediate files...")
  for (const style of styles) {
    if (existsSync(path.join(process.cwd(), `registry-${style.name}.json`))) {
      await fs.unlink(path.join(process.cwd(), `registry-${style.name}.json`))
    }
  }

  console.log("\nâœ… Build complete!")
} catch (error) {
  console.error(error)
  process.exit(1)
}
